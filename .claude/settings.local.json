{
  "permissions": {
    "allow": [
      "Bash(cat summary_20251211_0758*.json summary_20251211_0759*.json)",
      "Bash(cat \"C:\\\\Users\\\\Manu\\\\Documents\\\\Development\\\\ftxbot\\\\backtest_results\\\\summary_20251222_090724.json\")",
      "Bash(cat \"C:\\\\Users\\\\Manu\\\\Documents\\\\Development\\\\ftxbot\\\\backtest_results\\\\summary_20251222_090617.json\")",
      "Bash(cat \"C:\\\\Users\\\\Manu\\\\Documents\\\\Development\\\\ftxbot\\\\backtest_results\\\\summary_20251222_090638.json\")",
      "Bash(done)",
      "Bash(python -c \"\nimport pandas as pd\nfrom pathlib import Path\n\n# Compare a winner vs a loser\ndef analyze_trades\\(symbol\\):\n    files = list\\(Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\).glob\\(f''trades_*.csv''\\)\\)\n    for f in files:\n        df = pd.read_csv\\(f\\)\n        if len\\(df\\) > 0 and df[''symbol''].iloc[0] == symbol:\n            print\\(f''=== {symbol} ===''\\)\n            print\\(f''Total trades: {len\\(df\\)}''\\)\n            \n            # SL vs TP breakdown\n            sl_count = len\\(df[df[''status''] == ''CLOSED_SL'']\\)\n            tp_count = len\\(df[df[''status''] == ''CLOSED_TP'']\\)\n            print\\(f''TP hits: {tp_count} \\({tp_count/len\\(df\\)*100:.1f}%\\)''\\)\n            print\\(f''SL hits: {sl_count} \\({sl_count/len\\(df\\)*100:.1f}%\\)''\\)\n            \n            # Average pips won/lost\n            winners = df[df[''pnl''] > 0][''pnl_pips'']\n            losers = df[df[''pnl''] <= 0][''pnl_pips'']\n            print\\(f''Avg win: {winners.mean\\(\\):.1f} pips''\\)\n            print\\(f''Avg loss: {losers.mean\\(\\):.1f} pips''\\)\n            \n            # Direction breakdown\n            buys = df[df[''direction''] == ''BUY'']\n            sells = df[df[''direction''] == ''SELL'']\n            buy_wins = len\\(buys[buys[''pnl''] > 0]\\)\n            sell_wins = len\\(sells[sells[''pnl''] > 0]\\)\n            print\\(f''BUY trades: {len\\(buys\\)}, wins: {buy_wins} \\({buy_wins/len\\(buys\\)*100 if len\\(buys\\) > 0 else 0:.1f}%\\)''\\)\n            print\\(f''SELL trades: {len\\(sells\\)}, wins: {sell_wins} \\({sell_wins/len\\(sells\\)*100 if len\\(sells\\) > 0 else 0:.1f}%\\)''\\)\n            \n            # Look at consecutive losses\n            df[''is_loss''] = df[''pnl''] <= 0\n            max_consec_loss = 0\n            current = 0\n            for loss in df[''is_loss'']:\n                if loss:\n                    current += 1\n                    max_consec_loss = max\\(max_consec_loss, current\\)\n                else:\n                    current = 0\n            print\\(f''Max consecutive losses: {max_consec_loss}''\\)\n            print\\(\\)\n            return\n\n# Analyze best and worst\nfor sym in [''NZDJPY'', ''GBPAUD'', ''AUDCAD'', ''GBPJPY'', ''EURCHF'']:\n    analyze_trades\\(sym\\)\n\")",
      "Bash(python -c \"\nimport pandas as pd\nfrom pathlib import Path\n\ndef analyze_rr\\(symbol\\):\n    files = list\\(Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\).glob\\(f''trades_*.csv''\\)\\)\n    for f in files:\n        df = pd.read_csv\\(f\\)\n        if len\\(df\\) > 0 and df[''symbol''].iloc[0] == symbol:\n            print\\(f''=== {symbol} ===''\\)\n            \n            # Calculate intended SL and TP distances\n            df[''sl_dist''] = abs\\(df[''entry_price''] - df[''stop_loss'']\\)\n            df[''tp_dist''] = abs\\(df[''take_profit''] - df[''entry_price'']\\)\n            df[''intended_rr''] = df[''tp_dist''] / df[''sl_dist'']\n            \n            print\\(f''Intended R:R avg: {df[\"\"intended_rr\"\"].mean\\(\\):.2f}''\\)\n            print\\(f''Intended R:R min: {df[\"\"intended_rr\"\"].min\\(\\):.2f}''\\)\n            print\\(f''Intended R:R max: {df[\"\"intended_rr\"\"].max\\(\\):.2f}''\\)\n            \n            # Check SL distances in pips \\(need to know pip size\\)\n            # For JPY pairs pip = 0.01, for others pip = 0.0001\n            if ''JPY'' in symbol:\n                pip = 0.01\n            elif ''XAU'' in symbol:\n                pip = 0.01\n            else:\n                pip = 0.0001\n            \n            df[''sl_pips''] = df[''sl_dist''] / pip\n            df[''tp_pips''] = df[''tp_dist''] / pip\n            \n            print\\(f''Avg SL: {df[\"\"sl_pips\"\"].mean\\(\\):.1f} pips''\\)\n            print\\(f''Avg TP: {df[\"\"tp_pips\"\"].mean\\(\\):.1f} pips''\\)\n            print\\(f''Min SL: {df[\"\"sl_pips\"\"].min\\(\\):.1f} pips''\\)\n            print\\(f''Max SL: {df[\"\"sl_pips\"\"].max\\(\\):.1f} pips''\\)\n            \n            # Look at trade duration for losses vs wins\n            df[''entry_time''] = pd.to_datetime\\(df[''entry_time'']\\)\n            df[''exit_time''] = pd.to_datetime\\(df[''exit_time'']\\)\n            df[''duration_hours''] = \\(df[''exit_time''] - df[''entry_time'']\\).dt.total_seconds\\(\\) / 3600\n            \n            winners = df[df[''pnl''] > 0]\n            losers = df[df[''pnl''] <= 0]\n            print\\(f''Avg duration \\(wins\\): {winners[\"\"duration_hours\"\"].mean\\(\\):.1f} hours''\\)\n            print\\(f''Avg duration \\(losses\\): {losers[\"\"duration_hours\"\"].mean\\(\\):.1f} hours''\\)\n            print\\(\\)\n            return\n\nfor sym in [''NZDJPY'', ''GBPAUD'', ''AUDCAD'', ''GBPJPY'', ''EURCHF'']:\n    analyze_rr\\(sym\\)\n\")",
      "Bash(python -c \"\nimport pandas as pd\nfrom pathlib import Path\n\ndef analyze_price_behavior\\(symbol\\):\n    files = list\\(Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\).glob\\(f''trades_*.csv''\\)\\)\n    for f in files:\n        df = pd.read_csv\\(f\\)\n        if len\\(df\\) > 0 and df[''symbol''].iloc[0] == symbol:\n            print\\(f''=== {symbol} ===''\\)\n            \n            # For losing trades, how far did price go in the right direction before reversing?\n            losers = df[df[''status''] == ''CLOSED_SL''].copy\\(\\)\n            \n            if ''JPY'' in symbol:\n                pip = 0.01\n            else:\n                pip = 0.0001\n            \n            losers[''sl_dist''] = abs\\(losers[''entry_price''] - losers[''stop_loss'']\\) / pip\n            losers[''tp_dist''] = abs\\(losers[''take_profit''] - losers[''entry_price'']\\) / pip\n            \n            # The actual loss pips vs intended SL\n            # If actual loss < intended SL, trade closed early\n            # If actual loss == intended SL, hit full SL\n            losers[''loss_pips''] = abs\\(losers[''pnl_pips'']\\)\n            losers[''sl_efficiency''] = losers[''loss_pips''] / losers[''sl_dist'']  # 1.0 = full SL hit\n            \n            print\\(f''Losing trades: {len\\(losers\\)}''\\)\n            print\\(f''Avg loss vs SL: {losers[\"\"sl_efficiency\"\"].mean\\(\\):.2f} \\(1.0 = full SL\\)''\\)\n            print\\(f''Trades with full SL hit \\(>0.95\\): {len\\(losers[losers[\"\"sl_efficiency\"\"] > 0.95]\\)}''\\)\n            \n            # How many losing trades had loss bigger than SL? \\(slippage\\)\n            print\\(f''Trades with loss > SL: {len\\(losers[losers[\"\"sl_efficiency\"\"] > 1.05]\\)}''\\)\n            \n            # Check for trades that almost made it to TP then reversed\n            # A trade that goes 50%+ toward TP before reversing is a ''runner that failed''\n            \n            print\\(\\)\n            return\n\nfor sym in [''NZDJPY'', ''GBPAUD'', ''AUDCAD'', ''GBPJPY'', ''EURCHF'']:\n    analyze_price_behavior\\(sym\\)\n\")",
      "Bash(python -c \"\nimport pandas as pd\nfrom pathlib import Path\nimport json\n\nresults = []\nfor f in Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\).glob\\(''summary_*.json''\\):\n    data = json.loads\\(f.read_text\\(\\)\\)\n    symbol = data[''config''][''symbols''][0]\n    results.append\\({\n        ''symbol'': symbol,\n        ''trades'': data[''total_trades''],\n        ''win_rate'': data[''win_rate''],\n        ''pf'': data[''profit_factor''],\n        ''net'': data[''net_profit'']\n    }\\)\n\n# Calculate trades per month \\(1 year backtest period\\)\nprint\\(''Pair Characteristics Analysis''\\)\nprint\\(''=''*60\\)\nprint\\(f''{\"\"Symbol\"\":<10} {\"\"Trades\"\":<8} {\"\"Trades/Mo\"\":<10} {\"\"WinRate\"\":<8} {\"\"Verdict\"\"}''\\)\nprint\\(''-''*60\\)\n\n# Categorize by currency composition\njpy_pairs = []\ncommodity_cross = []\neur_range = []\ngbp_cross = []\n\nfor r in sorted\\(results, key=lambda x: x[''net''], reverse=True\\):\n    tpm = r[''trades''] / 12\n    sym = r[''symbol'']\n    \n    # Categorize\n    if ''JPY'' in sym:\n        cat = ''JPY-cross''\n    elif sym in [''AUDCAD'', ''AUDNZD'', ''NZDUSD'']:\n        cat = ''Commodity''  \n    elif sym in [''EURCHF'', ''EURGBP'']:\n        cat = ''EUR-range''\n    elif ''GBP'' in sym:\n        cat = ''GBP-cross''\n    elif ''USD'' in sym:\n        cat = ''USD-major''\n    else:\n        cat = ''Other''\n    \n    status = ''WIN'' if r[''net''] > 0 else ''LOSE''\n    \n    # Analysis\n    if r[''trades''] > 100 and r[''win_rate''] < 0.35:\n        note = ''OVERTRADING + LOW WR''\n    elif r[''win_rate''] < 0.30:\n        note = ''TOO MANY FALSE BREAKOUTS''\n    elif r[''pf''] > 1.5:\n        note = ''GOOD TRENDS''\n    elif r[''pf''] > 1.0:\n        note = ''MARGINAL''\n    else:\n        note = ''MEAN REVERTS''\n        \n    print\\(f''{sym:<10} {r[\"\"trades\"\"]:<8} {tpm:<10.1f} {r[\"\"win_rate\"\"]*100:<7.1f}% {note}''\\)\n\")",
      "Bash(python -c \"\nimport json\nfrom pathlib import Path\nimport pandas as pd\n\n# Load all summaries\nsummaries = []\nfor f in sorted\\(Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\).glob\\(''summary_*.json''\\)\\):\n    data = json.loads\\(f.read_text\\(\\)\\)\n    summaries.append\\(data\\)\n\n# Print all summaries for overview\nfor s in summaries:\n    symbol = s[''config''][''symbols''][0]\n    print\\(f''{symbol}: trades={s[\"\"total_trades\"\"]}, win_rate={s[\"\"win_rate\"\"]:.2%}, PF={s[\"\"profit_factor\"\"]:.2f}, net={s[\"\"net_profit\"\"]:.2f}, max_dd={s[\"\"max_drawdown\"\"]:.2%}''\\)\n\")",
      "Bash(python \"C:\\\\Users\\\\Manu\\\\Documents\\\\Development\\\\ftxbot\\\\analyze_backtest.py\")",
      "Bash(python -c \"\nimport pandas as pd\nfrom pathlib import Path\nimport json\n\nresults_dir = Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\)\n\n# Load all trades\nall_trades = []\nfor f in sorted\\(results_dir.glob\\(''trades_*.csv''\\)\\):\n    df = pd.read_csv\\(f\\)\n    all_trades.append\\(df\\)\ndf = pd.concat\\(all_trades, ignore_index=True\\)\n\nprint\\(''=''*80\\)\nprint\\(''RISK:REWARD ANALYSIS''\\)\nprint\\(''=''*80\\)\n\n# Calculate actual R:R achieved per trade\ndf[''risk''] = abs\\(df[''entry_price''] - df[''stop_loss'']\\)\ndf[''reward_potential''] = abs\\(df[''take_profit''] - df[''entry_price'']\\)\ndf[''actual_move''] = abs\\(df[''exit_price''] - df[''entry_price'']\\)\ndf[''intended_rr''] = df[''reward_potential''] / df[''risk'']\ndf[''actual_rr''] = df[''actual_move''] / df[''risk'']\n\nwinners = df[df[''pnl''] > 0]\nlosers = df[df[''pnl''] <= 0]\n\nprint\\(f''Intended R:R \\(avg\\): {df[\"\"intended_rr\"\"].mean\\(\\):.2f}''\\)\nprint\\(f''Actual R:R on wins \\(avg\\): {winners[\"\"actual_rr\"\"].mean\\(\\):.2f}''\\)\nprint\\(f''Actual R:R on losses \\(avg\\): {losers[\"\"actual_rr\"\"].mean\\(\\):.2f}''\\)\n\n# Distribution of RR on winners\nprint\\(\\)\nprint\\(''Winner R:R Distribution:''\\)\nrr_bins = [0, 1, 1.5, 2, 3, 100]\nfor i in range\\(len\\(rr_bins\\)-1\\):\n    count = len\\(winners[\\(winners[''actual_rr''] >= rr_bins[i]\\) & \\(winners[''actual_rr''] < rr_bins[i+1]\\)]\\)\n    print\\(f''  {rr_bins[i]:.1f}x - {rr_bins[i+1]:.1f}x R: {count} trades \\({count/len\\(winners\\)*100:.1f}%\\)''\\)\n\nprint\\(\\)\nprint\\(''=''*80\\)\nprint\\(''TOP 10 BEST TRADES''\\)\nprint\\(''=''*80\\)\ntop_trades = df.nlargest\\(10, ''pnl''\\)[[''symbol'', ''direction'', ''pnl'', ''pnl_pips'', ''entry_time'']]\nfor _, t in top_trades.iterrows\\(\\):\n    print\\(f''{t[\"\"symbol\"\"]:<8} {t[\"\"direction\"\"]:<5} +{t[\"\"pnl\"\"]:.0f} \\({t[\"\"pnl_pips\"\"]:.0f} pips\\) - {t[\"\"entry_time\"\"][:10]}''\\)\n\nprint\\(\\)\nprint\\(''=''*80\\)\nprint\\(''TOP 10 WORST TRADES''\\)\nprint\\(''=''*80\\)\nbottom_trades = df.nsmallest\\(10, ''pnl''\\)[[''symbol'', ''direction'', ''pnl'', ''pnl_pips'', ''entry_time'']]\nfor _, t in bottom_trades.iterrows\\(\\):\n    print\\(f''{t[\"\"symbol\"\"]:<8} {t[\"\"direction\"\"]:<5} {t[\"\"pnl\"\"]:.0f} \\({t[\"\"pnl_pips\"\"]:.0f} pips\\) - {t[\"\"entry_time\"\"][:10]}''\\)\n\")",
      "Bash(del \"C:\\\\Users\\\\Manu\\\\Documents\\\\Development\\\\ftxbot\\\\analyze_backtest.py\")",
      "Bash(rm \"C:\\\\Users\\\\Manu\\\\Documents\\\\Development\\\\ftxbot\\\\analyze_backtest.py\")",
      "Bash(python -c \"\nimport pandas as pd\nfrom pathlib import Path\nimport json\n\nresults_dir = Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\)\n\n# Load summaries for sorting by profit\nsummaries = []\nfor f in sorted\\(results_dir.glob\\(''summary_*.json''\\)\\):\n    data = json.loads\\(f.read_text\\(\\)\\)\n    summaries.append\\(data\\)\nsummaries.sort\\(key=lambda x: x[''net_profit''], reverse=True\\)\nsymbol_order = [s[''config''][''symbols''][0] for s in summaries]\n\n# Load all trades\nall_trades = []\nfor f in sorted\\(results_dir.glob\\(''trades_*.csv''\\)\\):\n    df = pd.read_csv\\(f\\)\n    all_trades.append\\(df\\)\ndf = pd.concat\\(all_trades, ignore_index=True\\)\n\nprint\\(''SL vs TP BREAKDOWN BY SYMBOL \\(sorted by profitability\\)''\\)\nprint\\(''=''*85\\)\nprint\\(f''{\"\"Symbol\"\":<10} {\"\"Trades\"\":<8} {\"\"TP\"\":<8} {\"\"SL\"\":<8} {\"\"TP%\"\":<8} {\"\"SL%\"\":<8} {\"\"Net P/L\"\":<12} {\"\"Status\"\"}''\\)\nprint\\(''-''*85\\)\n\nfor sym in symbol_order:\n    sym_df = df[df[''symbol''] == sym]\n    total = len\\(sym_df\\)\n    tp = len\\(sym_df[sym_df[''status''] == ''CLOSED_TP'']\\)\n    sl = len\\(sym_df[sym_df[''status''] == ''CLOSED_SL'']\\)\n    net = sym_df[''pnl''].sum\\(\\)\n    \n    tp_pct = tp/total*100\n    sl_pct = sl/total*100\n    \n    # Check if TP > SL\n    winner = ''PROFIT'' if net > 0 else ''LOSS''\n    tp_wins = ''TP>SL'' if tp > sl else ''SL>TP''\n    \n    print\\(f''{sym:<10} {total:<8} {tp:<8} {sl:<8} {tp_pct:<7.1f}% {sl_pct:<7.1f}% {net:>10.0f}  {winner} \\({tp_wins}\\)''\\)\n\nprint\\(''-''*85\\)\n# Totals\ntotal = len\\(df\\)\ntp = len\\(df[df[''status''] == ''CLOSED_TP'']\\)\nsl = len\\(df[df[''status''] == ''CLOSED_SL'']\\)\nprint\\(f''{\"\"TOTAL\"\":<10} {total:<8} {tp:<8} {sl:<8} {tp/total*100:<7.1f}% {sl/total*100:<7.1f}%''\\)\n\")",
      "Bash(python -c \"\nimport pandas as pd\nfrom pathlib import Path\n\nresults_dir = Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\)\n\nall_trades = []\nfor f in sorted\\(results_dir.glob\\(''trades_*.csv''\\)\\):\n    df = pd.read_csv\\(f\\)\n    all_trades.append\\(df\\)\ndf = pd.concat\\(all_trades, ignore_index=True\\)\n\nprint\\(''WHY PROFITABLE DESPITE SL > TP?''\\)\nprint\\(''=''*90\\)\nprint\\(f''{\"\"Symbol\"\":<10} {\"\"TP\"\":<6} {\"\"SL\"\":<6} {\"\"AvgWin\"\":<12} {\"\"AvgLoss\"\":<12} {\"\"W/L Ratio\"\":<10} {\"\"Net\"\":<10} {\"\"Breakeven WR\"\"}''\\)\nprint\\(''-''*90\\)\n\n# For each profitable symbol\nprofitable = [''XAUUSD'', ''AUDJPY'', ''EURJPY'', ''USDJPY'', ''EURUSD'', ''USDCHF'', ''AUDNZD'', ''USDCAD'', ''NZDJPY'', ''GBPCAD'', ''GBPUSD'', ''GBPAUD'', ''EURCAD'']\n\nfor sym in profitable:\n    sym_df = df[df[''symbol''] == sym]\n    tp = len\\(sym_df[sym_df[''status''] == ''CLOSED_TP'']\\)\n    sl = len\\(sym_df[sym_df[''status''] == ''CLOSED_SL'']\\)\n    \n    winners = sym_df[sym_df[''pnl''] > 0]\n    losers = sym_df[sym_df[''pnl''] <= 0]\n    \n    avg_win = winners[''pnl''].mean\\(\\) if len\\(winners\\) > 0 else 0\n    avg_loss = abs\\(losers[''pnl''].mean\\(\\)\\) if len\\(losers\\) > 0 else 0\n    \n    wl_ratio = avg_win / avg_loss if avg_loss > 0 else 0\n    net = sym_df[''pnl''].sum\\(\\)\n    \n    # Breakeven win rate = 1 / \\(1 + R:R\\)\n    breakeven_wr = 1 / \\(1 + wl_ratio\\) * 100 if wl_ratio > 0 else 0\n    actual_wr = len\\(winners\\) / len\\(sym_df\\) * 100\n    \n    margin = actual_wr - breakeven_wr\n    \n    print\\(f''{sym:<10} {tp:<6} {sl:<6} {avg_win:<12.2f} {avg_loss:<12.2f} {wl_ratio:<10.2f} {net:<10.0f} {breakeven_wr:.1f}% \\(actual: {actual_wr:.1f}%, +{margin:.1f}%\\)''\\)\n\nprint\\(\\)\nprint\\(''LOSING SYMBOLS:''\\)\nprint\\(''-''*90\\)\nlosers_list = [''GBPCHF'', ''NZDUSD'', ''EURGBP'', ''AUDUSD'', ''EURAUD'', ''GBPJPY'', ''EURCHF'', ''AUDCAD'']\n\nfor sym in losers_list:\n    sym_df = df[df[''symbol''] == sym]\n    tp = len\\(sym_df[sym_df[''status''] == ''CLOSED_TP'']\\)\n    sl = len\\(sym_df[sym_df[''status''] == ''CLOSED_SL'']\\)\n    \n    winners = sym_df[sym_df[''pnl''] > 0]\n    losers = sym_df[sym_df[''pnl''] <= 0]\n    \n    avg_win = winners[''pnl''].mean\\(\\) if len\\(winners\\) > 0 else 0\n    avg_loss = abs\\(losers[''pnl''].mean\\(\\)\\) if len\\(losers\\) > 0 else 0\n    \n    wl_ratio = avg_win / avg_loss if avg_loss > 0 else 0\n    net = sym_df[''pnl''].sum\\(\\)\n    \n    breakeven_wr = 1 / \\(1 + wl_ratio\\) * 100 if wl_ratio > 0 else 0\n    actual_wr = len\\(winners\\) / len\\(sym_df\\) * 100\n    \n    margin = actual_wr - breakeven_wr\n    \n    print\\(f''{sym:<10} {tp:<6} {sl:<6} {avg_win:<12.2f} {avg_loss:<12.2f} {wl_ratio:<10.2f} {net:<10.0f} {breakeven_wr:.1f}% \\(actual: {actual_wr:.1f}%, {margin:.1f}%\\)''\\)\n\")",
      "Bash(python -c \"\nimport json\nfrom pathlib import Path\n\n# Load summary\nwith open\\(''C:/Users/Manu/Documents/Development/ftxbot/sl_tp_research_results/all_symbols_summary.json''\\) as f:\n    data = json.load\\(f\\)\n\nprint\\(''=''*100\\)\nprint\\(''PRICE BEHAVIOR AFTER BREAKOUT \\(MFE = favorable, MAE = adverse\\)''\\)\nprint\\(''=''*100\\)\nprint\\(f''{\"\"Symbol\"\":<10} {\"\"Breakouts\"\":<10} {\"\"AvgMFE\"\":<10} {\"\"MedianMFE\"\":<12} {\"\"P75MFE\"\":<10} {\"\"AvgMAE\"\":<10} {\"\"MedianMAE\"\":<12} {\"\"MFE-MAE\"\":<10}''\\)\nprint\\(''-''*100\\)\n\npb = data[''price_behavior'']\nfor sym in sorted\\(pb.keys\\(\\)\\):\n    s = pb[sym]\n    diff = s[''avg_mfe''] - s[''avg_mae'']\n    marker = ''+'' if diff > 0 else ''''\n    print\\(f''{sym:<10} {s[\"\"breakouts\"\"]:<10} {s[\"\"avg_mfe\"\"]:<10.1f} {s[\"\"median_mfe\"\"]:<12.1f} {s[\"\"p75_mfe\"\"]:<10.1f} {s[\"\"avg_mae\"\"]:<10.1f} {s[\"\"median_mae\"\"]:<12.1f} {marker}{diff:<10.1f}''\\)\n\")",
      "Bash(python -c \"\nimport json\nfrom pathlib import Path\n\n# Load summary\nwith open\\(''C:/Users/Manu/Documents/Development/ftxbot/sl_tp_research_results/all_symbols_summary.json''\\) as f:\n    data = json.load\\(f\\)\n\nprint\\(''=''*110\\)\nprint\\(''OPTIMAL SL/TP PER SYMBOL \\(sorted by Expected Value\\)''\\)\nprint\\(''=''*110\\)\nprint\\(f''{\"\"Symbol\"\":<10} {\"\"BestSL\"\":<8} {\"\"BestTP\"\":<8} {\"\"R:R\"\":<6} {\"\"WinRate\"\":<10} {\"\"EV\"\":<10} {\"\"PF\"\":<8} {\"\"NetPips\"\":<12} {\"\"Trades\"\":<8}''\\)\nprint\\(''-''*110\\)\n\nresults = data[''sl_tp_results'']\n\nsymbol_best = []\nfor sym, sl_tp_data in results.items\\(\\):\n    # Find best combo by EV\n    best_key = max\\(sl_tp_data.keys\\(\\), key=lambda k: sl_tp_data[k][''ev_per_trade'']\\)\n    best = sl_tp_data[best_key]\n    symbol_best.append\\(\\(sym, best\\)\\)\n\n# Sort by EV descending\nsymbol_best.sort\\(key=lambda x: x[1][''ev_per_trade''], reverse=True\\)\n\nfor sym, best in symbol_best:\n    print\\(f''{sym:<10} {best[\"\"sl\"\"]:<8} {best[\"\"tp\"\"]:<8} {best[\"\"rr\"\"]:<6} {best[\"\"win_rate\"\"]:<9}% {best[\"\"ev_per_trade\"\"]:<10} {best[\"\"profit_factor\"\"]:<8} {best[\"\"net_pips\"\"]:<12} {best[\"\"total_resolved\"\"]:<8}''\\)\n\nprint\\(\\)\nprint\\(''=''*110\\)\nprint\\(''COMPARISON: OPTIMAL vs CURRENT \\(assuming current SL=20-25, TP=30-40 i.e. 1.5 R:R\\)''\\)\nprint\\(''=''*110\\)\n\")",
      "Bash(python -c \"\nimport json\n\nwith open\\(''C:/Users/Manu/Documents/Development/ftxbot/sl_tp_research_results/all_symbols_summary.json''\\) as f:\n    data = json.load\\(f\\)\n\nresults = data[''sl_tp_results'']\n\nprint\\(''=''*120\\)\nprint\\(''CURRENT 1.5 R:R PERFORMANCE vs OPTIMAL''\\)\nprint\\(''=''*120\\)\nprint\\(f''{\"\"Symbol\"\":<10} | {\"\"---CURRENT \\(SL20/TP30 ~1.5RR\\)---\"\":<40} | {\"\"---OPTIMAL---\"\":<40} | {\"\"EV Diff\"\":<10}''\\)\nprint\\(f''{\"\"\"\":<10} | {\"\"WR%\"\":<8} {\"\"EV\"\":<10} {\"\"PF\"\":<8} {\"\"Net\"\":<12} | {\"\"SL\"\":<4} {\"\"TP\"\":<4} {\"\"WR%\"\":<8} {\"\"EV\"\":<10} {\"\"PF\"\":<8} | {\"\"\"\":<10}''\\)\nprint\\(''-''*120\\)\n\n# Current-like settings to compare\ncurrent_key = ''20_30''  # SL=20, TP=30\n\nfor sym in sorted\\(results.keys\\(\\)\\):\n    sl_tp_data = results[sym]\n    \n    # Current performance\n    current = sl_tp_data.get\\(current_key, {}\\)\n    c_wr = current.get\\(''win_rate'', 0\\)\n    c_ev = current.get\\(''ev_per_trade'', 0\\)\n    c_pf = current.get\\(''profit_factor'', 0\\)\n    c_net = current.get\\(''net_pips'', 0\\)\n    \n    # Optimal\n    best_key = max\\(sl_tp_data.keys\\(\\), key=lambda k: sl_tp_data[k][''ev_per_trade'']\\)\n    best = sl_tp_data[best_key]\n    \n    ev_diff = best[''ev_per_trade''] - c_ev\n    diff_str = f''+{ev_diff:.3f}'' if ev_diff > 0 else f''{ev_diff:.3f}''\n    \n    print\\(f''{sym:<10} | {c_wr:<8} {c_ev:<10.3f} {c_pf:<8.2f} {c_net:<12.0f} | {best[\"\"sl\"\"]:<4} {best[\"\"tp\"\"]:<4} {best[\"\"win_rate\"\"]:<8} {best[\"\"ev_per_trade\"\"]:<10.3f} {best[\"\"profit_factor\"\"]:<8.2f} | {diff_str:<10}''\\)\n\nprint\\(\\)\nprint\\(''KEY INSIGHT: Most symbols perform better with LOWER R:R but HIGHER win rate!''\\)\n\")",
      "Bash(python -c \"\nimport json\n\nwith open\\(''C:/Users/Manu/Documents/Development/ftxbot/sl_tp_research_results/all_symbols_summary.json''\\) as f:\n    data = json.load\\(f\\)\n\nresults = data[''sl_tp_results'']\npb = data[''price_behavior'']\n\nprint\\(''=''*100\\)\nprint\\(''ANALYSIS: WHY WIDER SL + TIGHTER TP WORKS BETTER''\\)\nprint\\(''=''*100\\)\nprint\\(\\)\n\n# Group symbols by optimal pattern\ntight_sl_wide_tp = []  # Traditional trend-following \\(SL<=15, TP>=30\\)\nwide_sl_tight_tp = []  # Mean-reversion style \\(SL>=30, TP<=30\\)\nbalanced = []          # Middle ground\n\nfor sym in results.keys\\(\\):\n    sl_tp_data = results[sym]\n    best_key = max\\(sl_tp_data.keys\\(\\), key=lambda k: sl_tp_data[k][''ev_per_trade'']\\)\n    best = sl_tp_data[best_key]\n    \n    if best[''sl''] <= 15 and best[''tp''] >= 30:\n        tight_sl_wide_tp.append\\(\\(sym, best\\)\\)\n    elif best[''sl''] >= 30 and best[''tp''] <= 30:\n        wide_sl_tight_tp.append\\(\\(sym, best\\)\\)\n    else:\n        balanced.append\\(\\(sym, best\\)\\)\n\nprint\\(''TIGHT SL + WIDE TP \\(trend-following, RR >= 2.0\\):''\\)\nprint\\(''-''*60\\)\nfor sym, b in tight_sl_wide_tp:\n    mfe = pb[sym][''avg_mfe'']\n    mae = pb[sym][''avg_mae'']\n    print\\(f''  {sym:<10} SL={b[\"\"sl\"\"]} TP={b[\"\"tp\"\"]} RR={b[\"\"rr\"\"]} WR={b[\"\"win_rate\"\"]}% | MFE={mfe:.0f} MAE={mae:.0f}''\\)\n\nprint\\(\\)\nprint\\(''WIDE SL + TIGHT TP \\(mean-reversion, RR <= 0.75\\):''\\)\nprint\\(''-''*60\\)\nfor sym, b in wide_sl_tight_tp:\n    mfe = pb[sym][''avg_mfe'']\n    mae = pb[sym][''avg_mae'']\n    print\\(f''  {sym:<10} SL={b[\"\"sl\"\"]} TP={b[\"\"tp\"\"]} RR={b[\"\"rr\"\"]} WR={b[\"\"win_rate\"\"]}% | MFE={mfe:.0f} MAE={mae:.0f}''\\)\n\nprint\\(\\)\nprint\\(''BALANCED \\(RR 0.75-2.0\\):''\\)\nprint\\(''-''*60\\)\nfor sym, b in balanced:\n    mfe = pb[sym][''avg_mfe'']\n    mae = pb[sym][''avg_mae'']\n    print\\(f''  {sym:<10} SL={b[\"\"sl\"\"]} TP={b[\"\"tp\"\"]} RR={b[\"\"rr\"\"]} WR={b[\"\"win_rate\"\"]}% | MFE={mfe:.0f} MAE={mae:.0f}''\\)\n\nprint\\(\\)\nprint\\(''=''*100\\)\nprint\\(''THE CORE PROBLEM:''\\)\nprint\\(''=''*100\\)\nprint\\(\\)\nprint\\(''Your current strategy uses 1.5 R:R \\(SL~20, TP~30\\) which REQUIRES ~40% win rate.''\\)\nprint\\(''But the research shows:''\\)\nprint\\(\\)\nprint\\(''1. Most pairs have MAE >= MFE \\(price goes against you as much as for you\\)''\\)\nprint\\(''2. With SL=20 pips, you get stopped out BEFORE price can reach TP=30''\\)\nprint\\(''3. Wider SL \\(40 pips\\) survives the adverse move, allowing TP to be hit''\\)\nprint\\(\\)\nprint\\(''SOLUTION: Either WIDER SL or TIGHTER TP \\(or both\\) for most pairs''\\)\n\")",
      "Bash(python -c \"\nimport json\nfrom pathlib import Path\n\n# Check v2 results\nv2_dir = Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results_v2''\\)\nv1_dir = Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\)\n\nprint\\(''V2 RESULTS:''\\)\nprint\\(''=''*60\\)\nfor f in sorted\\(v2_dir.glob\\(''summary_*.json''\\)\\):\n    data = json.loads\\(f.read_text\\(\\)\\)\n    symbol = data[''config''][''symbols''][0]\n    trades = data[''total_trades'']\n    rr = data[''config''].get\\(''risk_reward_ratio'', ''N/A''\\)\n    min_sl = data[''config''].get\\(''min_stop_loss_pips'', ''N/A''\\)\n    min_rr = data[''config''].get\\(''min_rr'', ''N/A''\\)\n    print\\(f''{symbol}: {trades} trades, RR={rr}, min_sl={min_sl}, min_rr={min_rr}''\\)\n\nprint\\(\\)\nprint\\(''V1 RESULTS \\(for comparison\\):''\\)\nprint\\(''=''*60\\)\nfor f in sorted\\(v1_dir.glob\\(''summary_*.json''\\)\\):\n    data = json.loads\\(f.read_text\\(\\)\\)\n    symbol = data[''config''][''symbols''][0]\n    trades = data[''total_trades'']\n    rr = data[''config''].get\\(''risk_reward_ratio'', ''N/A''\\)\n    min_sl = data[''config''].get\\(''min_stop_loss_pips'', ''N/A''\\)\n    print\\(f''{symbol}: {trades} trades, RR={rr}, min_sl={min_sl}''\\)\n\")",
      "Bash(python -c \"\nimport json\nfrom pathlib import Path\nimport pandas as pd\n\nv1_dir = Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results''\\)\nv2_dir = Path\\(''C:/Users/Manu/Documents/Development/ftxbot/backtest_results_v2''\\)\n\n# Load v1 results\nv1_results = {}\nfor f in sorted\\(v1_dir.glob\\(''summary_*.json''\\)\\):\n    data = json.loads\\(f.read_text\\(\\)\\)\n    symbol = data[''config''][''symbols''][0]\n    v1_results[symbol] = data\n\n# Load v2 results\nv2_results = {}\nfor f in sorted\\(v2_dir.glob\\(''summary_*.json''\\)\\):\n    data = json.loads\\(f.read_text\\(\\)\\)\n    symbol = data[''config''][''symbols''][0]\n    v2_results[symbol] = data\n\nprint\\(''=''*120\\)\nprint\\(''V1 vs V2 COMPARISON''\\)\nprint\\(''=''*120\\)\nprint\\(f''{\"\"Symbol\"\":<10} | {\"\"---V1 \\(1.5 R:R\\)---\"\":<45} | {\"\"---V2 \\(Optimized\\)---\"\":<45} | {\"\"Diff\"\":<10}''\\)\nprint\\(f''{\"\"\"\":<10} | {\"\"Trades\"\":<8} {\"\"WR%\"\":<8} {\"\"PF\"\":<8} {\"\"Net\"\":<12} {\"\"RR\"\":<6} | {\"\"Trades\"\":<8} {\"\"WR%\"\":<8} {\"\"PF\"\":<8} {\"\"Net\"\":<12} {\"\"RR\"\":<6} | {\"\"\"\":<10}''\\)\nprint\\(''-''*120\\)\n\ntotal_v1 = 0\ntotal_v2 = 0\nimproved = 0\ndegraded = 0\n\nfor symbol in sorted\\(v1_results.keys\\(\\)\\):\n    v1 = v1_results.get\\(symbol\\)\n    v2 = v2_results.get\\(symbol\\)\n    \n    if not v1 or not v2:\n        continue\n    \n    v1_net = v1[''net_profit'']\n    v2_net = v2[''net_profit'']\n    diff = v2_net - v1_net\n    \n    total_v1 += v1_net\n    total_v2 += v2_net\n    \n    if diff > 0:\n        improved += 1\n        diff_str = f''+{diff:.0f}''\n    else:\n        degraded += 1\n        diff_str = f''{diff:.0f}''\n    \n    v1_rr = v1[''config''].get\\(''risk_reward_ratio'', 1.5\\)\n    v2_rr = v2[''config''].get\\(''risk_reward_ratio'', 1.5\\)\n    \n    print\\(f''{symbol:<10} | {v1[\"\"total_trades\"\"]:<8} {v1[\"\"win_rate\"\"]*100:<7.1f}% {v1[\"\"profit_factor\"\"]:<8.2f} {v1_net:<11.0f} {v1_rr:<6} | {v2[\"\"total_trades\"\"]:<8} {v2[\"\"win_rate\"\"]*100:<7.1f}% {v2[\"\"profit_factor\"\"]:<8.2f} {v2_net:<11.0f} {v2_rr:<6} | {diff_str:<10}''\\)\n\nprint\\(''-''*120\\)\nprint\\(f''{\"\"TOTAL\"\":<10} | {\"\"\"\":<8} {\"\"\"\":<8} {\"\"\"\":<8} {total_v1:<11.0f} {\"\"\"\":<6} | {\"\"\"\":<8} {\"\"\"\":<8} {\"\"\"\":<8} {total_v2:<11.0f} {\"\"\"\":<6} | {total_v2-total_v1:+.0f}''\\)\nprint\\(\\)\nprint\\(f''Symbols Improved: {improved}/{len\\(v1_results\\)}''\\)\nprint\\(f''Symbols Degraded: {degraded}/{len\\(v1_results\\)}''\\)\nprint\\(f''Net Change: {total_v2-total_v1:+,.0f} \\({\\(total_v2-total_v1\\)/total_v1*100:+.1f}%\\)''\\)\n\")",
      "Bash(python -c \"\nimport json\nfrom pathlib import Path\n\nwith open\\(''C:/Users/Manu/Documents/Development/ftxbot/sl_tp_research_results/all_symbols_summary.json''\\) as f:\n    data = json.load\\(f\\)\n\nresults = data[''sl_tp_results'']\n\nprint\\(''=''*100\\)\nprint\\(''COMPARING DIFFERENT R:R APPROACHES FROM RESEARCH''\\)\nprint\\(''=''*100\\)\nprint\\(\\)\nprint\\(f''{\"\"Symbol\"\":<10} | {\"\"---Low RR \\(0.5-0.75\\)---\"\":<30} | {\"\"---1:1 RR---\"\":<30} | {\"\"---1.5 RR \\(current\\)---\"\":<30}''\\)\nprint\\(f''{\"\"\"\":<10} | {\"\"SL/TP\"\":<8} {\"\"WR%\"\":<6} {\"\"EV\"\":<8} {\"\"PF\"\":<6} | {\"\"SL/TP\"\":<8} {\"\"WR%\"\":<6} {\"\"EV\"\":<8} {\"\"PF\"\":<6} | {\"\"SL/TP\"\":<8} {\"\"WR%\"\":<6} {\"\"EV\"\":<8} {\"\"PF\"\":<6}''\\)\nprint\\(''-''*100\\)\n\nfor sym in sorted\\(results.keys\\(\\)\\):\n    sl_tp = results[sym]\n    \n    # Find best low RR combo \\(0.5-0.75\\)\n    low_rr = [\\(k, v\\) for k, v in sl_tp.items\\(\\) if 0.4 <= v[''rr''] <= 0.8]\n    low_rr_best = max\\(low_rr, key=lambda x: x[1][''ev_per_trade'']\\) if low_rr else None\n    \n    # Find best 1:1 combo \\(0.9-1.1\\)\n    one_to_one = [\\(k, v\\) for k, v in sl_tp.items\\(\\) if 0.9 <= v[''rr''] <= 1.1]\n    one_best = max\\(one_to_one, key=lambda x: x[1][''ev_per_trade'']\\) if one_to_one else None\n    \n    # Find 1.5 RR combo \\(current\\)\n    high_rr = [\\(k, v\\) for k, v in sl_tp.items\\(\\) if 1.4 <= v[''rr''] <= 1.6]\n    high_best = max\\(high_rr, key=lambda x: x[1][''ev_per_trade'']\\) if high_rr else None\n    \n    # Format output\n    if low_rr_best:\n        l = low_rr_best[1]\n        low_str = f''{l[\"\"sl\"\"]}/{l[\"\"tp\"\"]:<5} {l[\"\"win_rate\"\"]:<5}% {l[\"\"ev_per_trade\"\"]:<7} {l[\"\"profit_factor\"\"]:<5}''\n    else:\n        low_str = ''N/A''\n    \n    if one_best:\n        o = one_best[1]\n        one_str = f''{o[\"\"sl\"\"]}/{o[\"\"tp\"\"]:<5} {o[\"\"win_rate\"\"]:<5}% {o[\"\"ev_per_trade\"\"]:<7} {o[\"\"profit_factor\"\"]:<5}''\n    else:\n        one_str = ''N/A''\n        \n    if high_best:\n        h = high_best[1]\n        high_str = f''{h[\"\"sl\"\"]}/{h[\"\"tp\"\"]:<5} {h[\"\"win_rate\"\"]:<5}% {h[\"\"ev_per_trade\"\"]:<7} {h[\"\"profit_factor\"\"]:<5}''\n    else:\n        high_str = ''N/A''\n    \n    print\\(f''{sym:<10} | {low_str:<30} | {one_str:<30} | {high_str:<30}''\\)\n\nprint\\(\\)\nprint\\(''=''*100\\)\nprint\\(''INSIGHT: 1:1 R:R provides BALANCED risk - you win/lose same amount''\\)\nprint\\(''=''*100\\)\n\")"
    ],
    "deny": [],
    "ask": []
  }
}
